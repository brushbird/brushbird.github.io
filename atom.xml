<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damer 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.damerwang.com/"/>
  <updated>2017-12-18T02:59:46.551Z</updated>
  <id>http://www.damerwang.com/</id>
  
  <author>
    <name>Damer Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>译：Code Splitting with Vue.js And Webpack</title>
    <link href="http://www.damerwang.com/2017/12/18/page2/"/>
    <id>http://www.damerwang.com/2017/12/18/page2/</id>
    <published>2017-12-18T02:57:02.000Z</published>
    <updated>2017-12-18T02:59:46.551Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用webpack来打包你的单页应用的一个可能的缺点是你可能会得到一个非常大的打包文件，有时甚至会有几兆大小。<br> Asset | Size<br>———|———:<br>bundle.main.js | 1.36MB<br>&emsp;&emsp;随之带来的问题是用户在屏幕上看到任何东西之前，必须要下载整个文件并运行它。如果用户使用的是网络连接不好的设备，这个过程可能需要很长时间。<br>&emsp;&emsp;<strong><em>Code splitting</em></strong> 就是把打包文件分割成为更小的文件，允许用户在他们需要的时候下载需要的代码块的一个方法。<br>&emsp;&emsp;例如，看看这个简单的界面，我们可以识别出这个App中不需要初始载入的部分。  </p><p><img src="https://d33wubrfki0l68.cloudfront.net/f08875090748f1879db7b8783eef981e6bf2ea2d/0c121/images/posts/code_splitting_01.png" alt="image"><br>&emsp;&emsp;如果我们延迟加载这些代码段直到初始渲染结束会怎样？它可以让用户更快的看到界面并进行交互。<br>&emsp;&emsp;在这篇文章，我将向你展示如何使用<strong>Vue.js</strong> 和 <strong>Webpack</strong>将单页应用拆分成可以动态加载的更理想的大小。  </p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>&emsp;&emsp;Code splitting 的关键就是异步组件（<em>async components</em>），这个组件的定义就是异步加载（包括它的模板，数据，方法等等）。<br>&emsp;&emsp;首先让我们用<em>component API</em> 即 <em>Vue.component(name, definition)</em> 声明一个组件。不同于将定义对象作为第二个参数，异步组件有一个函数，这个函数有两个显著的特点：</p><ul><li>它执行 Promise，拥有一个 resolve 参数</li><li><p>它是一个工厂函数，也就是说它返回一个对象(在本例中是组件定义)<br><pre><code><br>Vue.component(‘async-component’, (resolve) =&gt; {<br>resolve({<br>  template: ‘<div>Async Component</div>‘,<br>  props: [ ‘myprop’ ]<br>});<br>});<br></code></pre><br>异步组件是 <em>Code splitting</em> 的第一步，因为我们现在才有了一个抽象的机制。  </p><h3 id="动态模块加载"><a href="#动态模块加载" class="headerlink" title="动态模块加载"></a>动态模块加载</h3><p>&emsp;&emsp;我们还需要 <em>webpack</em> 的帮助，假设我们将组件定义抽象为ES6模块文件:  </p><p><strong>AsyncComponent.js</strong><br><pre><code><br>export default {<br>template: ‘<div>Async Component</div>‘,<br>props: [ ‘myprop’ ]<br>}<br></code></pre><br>&emsp;&emsp;我们怎么让Vue.js加载它呢？你可能会想试试这样的方法：<br><pre><code><br>import AsyncComponent from ‘./AsyncComponent.js’`;<br>Vue.component(‘async-component’, AsyncComponent);<br></code></pre><br>&emsp;&emsp;但是这是静态的并且在编译时解析，如果我们想要获得<em>Code splitting</em> 的好处，我们需要的是在运行的应用中动态地加载。</p><h4 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h4><p>&emsp;&emsp;目前，用JavaScript来动态的加载模块是不可能的。但是，ECMAScript有一个动态模块加载函数叫做 <em>import()</em>  。<br>&emsp;&emsp;Webpack已经有了一个import()的实现，并将其作为一个代码分割点，在创建包时，将所请求的模块放入一个单独的文件中（一个单独的chunk，实际上，现在把它看作单独的一个文件）。<br>&emsp;&emsp;import() 将文件名作为一个参数并返回一个Promise。下面是我们如何加载上面的模块：<br><pre><code><br>import(/<em> webpackChunkName: “async-component” </em>/ ‘./AsyncComponent.js’)<br>.then((AsyncComponent) =&gt; {<br>  console.log(AsyncComponent.default.template);<br>  // Output: <div>Async Component</div><br>});<br></code></pre></p><blockquote><p><strong><em>注：如果你使用Babel，你需要添加</em></strong> <em>syntax-dynamic-import</em> 插件<strong><em>以便Babel可以正确的解析。</em></strong></p></blockquote></li></ul><p>现在，但你构建项目的时候，你会注意到这些模块出现在它自己的文件中了：</p><table><thead><tr><th>Asset</th><th style="text-align:right">Chuck Name</th></tr></thead><tbody><tr><td>bundle.main.js</td><td style="text-align:right">main</td></tr><tr><td>bundle.0.js</td><td style="text-align:right">async-component</td></tr></tbody></table><blockquote><p><strong><em>你可以给动态导入的模块加一个名字，让它更容易识别；只需在文件名前面添加一个注释，就像我在上面的例子中所做的那样。</em></strong></p><h3 id="动态组件加载"><a href="#动态组件加载" class="headerlink" title="动态组件加载"></a>动态组件加载</h3></blockquote><p>&emsp;&emsp;因为 <em>import()</em> 返回一个Promise，我们可以将它和 <em>Vue</em> 的异步组件功能结合使用。Webpack将单独打包异步组件，并通过AJAX将其动态加载到应用程序中。</p><p>  <strong>main.js</strong></p><pre><code>import Vue from 'vue';Vue.component('async-component', (resolve) => {  import('./AsyncComponent.js')    .then((AsyncComponent) => {      resolve(AsyncComponent.default);    });});new Vue({   el: '#app' });</code></pre>  <p>  <strong>index.html</strong></p><pre><code><div id="app">  <p>This part is included in the page load</p>  <async-component></async-component></div><script src="bundle.main.js"></script></code></pre>    <p>  <strong>页面初始加载时：</strong></p><pre><code><div id="app">  <p>This part is included in the page load</p></div></code></pre>        <p>  当main.js运行的时候，它将启动异步组件模块的请求（这是自动实现的，因为 <em>webpack</em> 的 <em>import()</em> 包含了AJAX加载模块的代码）。<br>  如果Ajax成功返回模块，Promise 完成并且渲染组件，页面将会被渲染成这样：  </p> <pre><code><div id="app">  <p>This part is included in the page load</p>  <div>Async Component</div></div></code></pre>         **下图可以更好地帮助你理解：**  ![image](https://d33wubrfki0l68.cloudfront.net/67be4bc46f37830bc390a151acb3fffe971062ec/eac15/images/posts/code_splitting_02.png)### single file component&emsp;&emsp;Vue 实现 *Code Splitting* 的特殊方式就是使用 *single file component*。下面是使用single file component的代码重构：**AsyncComponent.vue**  <pre><code><template>  <div>Async Component</div></template><script>  export default {    props: [ 'myprop' ]  }</script></code></pre>     <p><strong>导入的语法也更加简洁</strong></p><pre><code>new Vue({   el: '#app',  components: {    AsyncComponent: () => import('./AsyncComponent.vue')  }});</code></pre>    <h3 id="Code-Splitting-架构"><a href="#Code-Splitting-架构" class="headerlink" title="Code Splitting 架构"></a>Code Splitting 架构</h3><p>&emsp;&emsp;这是无关技术的部分，问题就是我们怎么为一个app构建一个code splitting ？<br>&emsp;&emsp;最直接的方法就是按照界面来，比如，你的app上有两个界面，一个home，一个about。这两个界面是由两个组件（home.vue about.vue）构成，那么这两个组件就可以是拆分的点。<br>&emsp;&emsp;另外，你也可以对任何有条件的组件（选项卡、弹窗、下拉菜单等等）或者是footer进行拆分。</p><blockquote><p>原文地址：<a href="https://vuejsdevelopers.com/2017/07/03/vue-js-code-splitting-webpack/" target="_blank" rel="noopener">Code Splitting with Vue.js And Webpack</a><br>译者：<a href="http://www.damerwang.com">Damer Wang</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;用webpack来打包你的单页应用的一个可能的缺点是你可能会得到一个非常大的打包文件，有时甚至会有几兆大小。&lt;br&gt; Asset | Size&lt;br&gt;———|———:&lt;br&gt;bundle.main.js | 1.36MB&lt;br&gt;&amp;emsp;&amp;emsp
      
    
    </summary>
    
    
      <category term="vue webpack" scheme="http://www.damerwang.com/tags/vue-webpack/"/>
    
  </entry>
  
  <entry>
    <title>Damer-cli：帮你优化HTTP请求结构的脚手架</title>
    <link href="http://www.damerwang.com/2017/12/09/page1/"/>
    <id>http://www.damerwang.com/2017/12/09/page1/</id>
    <published>2017-12-09T08:10:30.000Z</published>
    <updated>2017-12-09T09:42:35.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 写在前面：最近一直在用 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a>       做后台管理系统。大家也都知道这种后台管理系统，用组件库的话很快就能搭出一个像样的界面出来，但是他的请求远比单页面复杂得多，逻辑也更复杂一点。http请求有一个清晰的结构不仅有利于开发，也有利别人接手，本篇文章就是给大家分享一些优化的方法，第一次写文章，如果有的地方写的不对或是没有表达清楚，欢迎大家给我提 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">issues</a></p></blockquote><h3 id="代码结构就不展示了，大家可以去-这里-查看，本篇文章主要给大家分享一下其中的-api-和-store"><a href="#代码结构就不展示了，大家可以去-这里-查看，本篇文章主要给大家分享一下其中的-api-和-store" class="headerlink" title="代码结构就不展示了，大家可以去 这里 查看，本篇文章主要给大家分享一下其中的 api 和 store"></a>代码结构就不展示了，大家可以去 <a href="https://github.com/brushbird/Damer-cli" target="_blank" rel="noopener">这里</a> 查看，本篇文章主要给大家分享一下其中的 api 和 store</h3><ul><li><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="1-urlConfig-js"><a href="#1-urlConfig-js" class="headerlink" title="1. urlConfig.js"></a>1. urlConfig.js</h4></li></ul><pre><code>// 在这个页面中，将后台的请求集合起来，统一管理(function() {    var BASE_URL = window.oPageConfig.oData.BASE_URL;    function URLConfig(which, data) {        var url;        switch (which) {            /*********************基础信息*********************/            case 'baseInfo':                return BASE_URL + 'info'; // 菜单列表        }    }    window.URLConfig = URLConfig;})();</code></pre><h4 id="2-index-js"><a href="#2-index-js" class="headerlink" title="2. index.js"></a>2. index.js</h4><pre><code>import http from './http.js';import urlConfig from './urlConfig.js';//在这里注册 HTTP请求export function getBaseInfo (){    return http({url: URLConfig('baseInfo')});}</code></pre><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h4><pre><code>import * as Api from 'api/index.js'methods: {  loadData: function() {    Api.getBaseInfo().then((data)=>{        // todo    }, error=>{        //todo    })  }},</code></pre><h5 id="这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在-api-中进行修改就可以了。-同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。"><a href="#这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在-api-中进行修改就可以了。-同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。" class="headerlink" title="这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在 api 中进行修改就可以了。 同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。"></a>这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在 api 中进行修改就可以了。 同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。</h5><ul><li><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><blockquote><p>vuex的使用方法不用多说，这里主要是将公共方法抽取出来，放到actions中去，具体操作如下： </p></blockquote></li></ul><pre><code>import testA from './testA.js';import testB from './testB.js';import * as Api from 'src/api';const state = {};const getters = {};const actions = {    //在这里将公共的操作提取出来，对公共的数据进行统一的操作    //获取信息    loadBaseInfo({ dispatch, commit }, params) {        return new Promise((resolve, reject) => {            Api.getBaseInfo(params).then(data => {                commit('UPDATE_BASEINFO', data.list);                resolve(data);            }, error => {                reject(error);            });        })    }};const mutations = {    UPDATE_BASEINFO(state, data) {        //todo    }};export default {    namespaced: true,    state,    getters,    actions,    mutations,    modules: {        testA,        testB,    }}</code></pre><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><pre><code>import { mapState, mapMutations, mapActions } from "vuex";computed: {    ...mapState("modules/testA", {      变量名: state => state.变量名,    }),    ...mapState("modules/testB", {      变量名: state => state.变量名,    })},methods: {    //注意这里的modules是指引用在index.js中的父组件的模块名称    /*例如    *在store/index.js中    *  " import baseModule from './modules/base.js'; "    *那么下面的引用路径就要变成("baseModule/testA");    */    ...mapActions("modules/testA", [      "方法名"    ]),     ...mapActions("modules/testB", [      "方法名"    ]),    ...mapMutations("modules/testA", [      "方法名"    ]),    ...mapMutations("modules/testB", [      "方法名"    ]),}</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p> 对于一个组件拥有多个组件，同时各组件之间有数据联系的情况，可以通过为每个组件都建立一个store文件，然后在父组件中引用的方式解决，当然，在子文件中都需要加上 ==namespaced: true== </p></blockquote><h5 id="这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护"><a href="#这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护" class="headerlink" title="这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护"></a>这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护</h5><h4 id="写在最后：-我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用-api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到-issues-中来。同样，如果这篇文章有什么问题的话也请移步-这里-。"><a href="#写在最后：-我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用-api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到-issues-中来。同样，如果这篇文章有什么问题的话也请移步-这里-。" class="headerlink" title="==写在最后：== 我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用 api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到 issues 中来。同样，如果这篇文章有什么问题的话也请移步 这里 。"></a>==写在最后：== 我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用 api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">issues</a> 中来。同样，如果这篇文章有什么问题的话也请移步 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">这里</a> 。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 写在前面：最近一直在用 &lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;       做后台管理系统。大家也都知道这种后台管理系统，用组件库的话很快就能搭
      
    
    </summary>
    
    
  </entry>
  
</feed>
