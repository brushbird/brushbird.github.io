<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Damer 的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.damerwang.com/"/>
  <updated>2018-01-20T09:32:04.294Z</updated>
  <id>http://www.damerwang.com/</id>
  
  <author>
    <name>Damer Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信浏览器的rem使用总结（加强行安利）</title>
    <link href="http://www.damerwang.com/2018/01/20/page4/"/>
    <id>http://www.damerwang.com/2018/01/20/page4/</id>
    <published>2018-01-20T09:27:13.000Z</published>
    <updated>2018-01-20T09:32:04.294Z</updated>
    
    <content type="html"><![CDATA[<p>首先，让我们来明确一个概念</p><blockquote><p>rem（font size of the root element）是指相对于根元素的字体大小的单位（可以联想一下em）。  </p></blockquote><h4 id="1-网页载入文字从小变大的情况"><a href="#1-网页载入文字从小变大的情况" class="headerlink" title="1. 网页载入文字从小变大的情况"></a>1. 网页载入文字从小变大的情况</h4><p>只考虑微信等正常竖屏浏览器里话，可以用css直接把大部分机型的根字体大小定义好，例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@media screen and (max-width: 320px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 42.667px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 321px) and (max-width: 360px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 48px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 361px) and (max-width: 375px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 50px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 376px) and (max-width: 393px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 52.4px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 394px) and (max-width: 412px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 54.93px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 413px) and (max-width: 414px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 55.2px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 415px) and (max-width: 480px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 64px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 481px) and (max-width: 540px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 72px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 541px) and (max-width: 640px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 85.33px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 641px) and (max-width: 720px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 96px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 721px) and (max-width: 768px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 102.4px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media screen and (min-width: 769px) &#123;</span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 102.4px;</span><br><span class="line">        font-size: -webkit-calc(13.33333333vw);</span><br><span class="line">        font-size: calc(13.33333333vw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可直接粘贴使用，如果考虑的webview的话，就需要使用js设置html根目录的font-size了。</p><h4 id="2-rem设定导致尺寸不对"><a href="#2-rem设定导致尺寸不对" class="headerlink" title="2. rem设定导致尺寸不对"></a>2. rem设定导致尺寸不对</h4><p>接上一个问题，在不使用js动态设定font-size的情况下，通常我们会使用1rem=100px作为基础单位，在设计稿是750px宽的时候真的是相当方便，根据上面的css，750px的font-size是102.4px,不过这2.4px是可以忽略了，肉眼是看不出多大区别的。但当我拿到640px宽度的设计稿时，font-size是85.3px，这种情况下如果还是按照1rem=100px来计算就会出现问题了，这种时候就要把rem的基础单位改成85px了。身患懒癌晚期的人啊，可是连这都不想算的，所以</p><h4 id="3-前人栽树，后人乘凉啊"><a href="#3-前人栽树，后人乘凉啊" class="headerlink" title="3.前人栽树，后人乘凉啊"></a>3.前人栽树，后人乘凉啊</h4><p>你以为我的安利就只有rem屏幕自适应设定吗，太天真，废话不多说，都在<a href="https://github.com/brushbird/fis3-mobile" target="_blank" rel="noopener">README这里</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，让我们来明确一个概念&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;rem（font size of the root element）是指相对于根元素的字体大小的单位（可以联想一下em）。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-网页载入文字从小变大的
      
    
    </summary>
    
    
      <category term="rem" scheme="http://www.damerwang.com/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件通信之Bus</title>
    <link href="http://www.damerwang.com/2017/12/27/page3/"/>
    <id>http://www.damerwang.com/2017/12/27/page3/</id>
    <published>2017-12-27T08:05:01.000Z</published>
    <updated>2017-12-27T08:13:33.678Z</updated>
    
    <content type="html"><![CDATA[<p>关于组件通信我相信小伙伴们肯定也都很熟悉，就不多说了，对组件通信还不熟悉的小伙伴移步<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">这里</a>。<br>在vue2.0中 $dispatch 和 $broadcast 已经被弃用。官方文档中给出的解释是：  </p><blockquote><p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，我们也不希望在以后让开发者们太痛苦。并且$dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。  </p></blockquote><p>官方推荐的状态管理方案是 <a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a>。不过如果项目不是很大，状态管理也没有很复杂的话，使用 <strong>Vuex</strong> 有种杀鸡用牛刀的感觉，当然，这也是要根据自己的需求来的，只是建议。  </p><p>vue官方文档中有这样一个定义：<a href="https://cn.vuejs.org/v2/guide/components.html#%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">非父子组件的通信</a>，内容很少，如下：<br><img src="https://user-gold-cdn.xitu.io/2017/12/27/16096fe025e1371b?w=700&amp;h=363&amp;f=png&amp;s=47717" alt="image">  </p><p>其实关于这个<strong>非父子组件通信</strong>的demo还是有的，它藏在了<a href="https://cn.vuejs.org/v2/guide/migration.html#dispatch-%E5%92%8C-broadcast-%E6%9B%BF%E6%8D%A2" target="_blank" rel="noopener">$dispatch 和 $broadcast的迁移文档中</a>，有兴趣的小伙伴可以点击进去查看。文档中的建议就是：</p><blockquote><p><strong>对于$dispatch 和 $broadcast最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的。</strong> </p></blockquote><p>这个<strong>集中式的事件中间件</strong>就是 <strong>Bus</strong>。我习惯将bus定义到全局：  </p><p>app.js<br> <pre><code><br>var eventBus = {<br>    install(Vue,options) {<br>        Vue.prototype.$bus = vue<br>    }<br>};<br>Vue.use(eventBus);<br> </code></pre>    </p><p>然后在组件中，可以使用$emit， $on， $off 分别来分发、监听、取消监听事件：  </p><p>分发事件的组件</p> <pre><code>// ...methods: {  todo: function () {    this.$bus.$emit('todoSth', params);  //params是传递的参数    //...  }} </code></pre>    <p>监听的组件</p> <pre><code>// ...created() {  this.$bus.$on('todoSth', (params) => {  //获取传递的参数并进行操作      //todo something  })},// 最好在组件销毁前// 清除事件监听beforeDestroy () {  this.$bus.$off('todoSth');}, </code></pre>    <p>如果需要监听多个组件，只需要更改 <strong>bus</strong> 的 <strong>eventName</strong>:</p> <pre><code>// ...created() {  this.$bus.$on('firstTodo', this.firstTodo);  this.$bus.$on('secondTodo', this.secondTodo);},// 清除事件监听beforeDestroy () {  this.$bus.$off('firstTodo', this.firstTodo);  this.$bus.$off('secondTodo', this.secondTodo);}, </code></pre>  <p>如果文章有错误或是有什么疑问，欢迎在评论中交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于组件通信我相信小伙伴们肯定也都很熟悉，就不多说了，对组件通信还不熟悉的小伙伴移步&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;
      
    
    </summary>
    
    
      <category term="vue.js vuex" scheme="http://www.damerwang.com/tags/vue-js-vuex/"/>
    
  </entry>
  
  <entry>
    <title>译：Code Splitting with Vue.js And Webpack</title>
    <link href="http://www.damerwang.com/2017/12/18/page2/"/>
    <id>http://www.damerwang.com/2017/12/18/page2/</id>
    <published>2017-12-18T02:57:02.000Z</published>
    <updated>2017-12-27T08:16:39.035Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;用webpack来打包你的单页应用的一个可能的缺点是你可能会得到一个非常大的打包文件，有时甚至会有几兆大小。   </p><table><br>    <tr><br>      <th>Asset</th><br>      <th>Size</th><br>    </tr><br>    <tr><br>      <td>bundle.main.js</td><br>      <td>1.36MB</td><br>    </tr><br></table><br>&emsp;&emsp;随之带来的问题是用户在屏幕上看到任何东西之前，必须要下载整个文件并运行它。如果用户使用的是网络连接不好的设备，这个过程可能需要很长时间。<br>&emsp;&emsp;<strong><em>Code splitting</em></strong> 就是把打包文件分割成为更小的文件，允许用户在他们需要的时候下载需要的代码块的一个方法。<br>&emsp;&emsp;例如，看看这个简单的界面，我们可以识别出这个App中不需要初始载入的部分。<br><br><img src="https://d33wubrfki0l68.cloudfront.net/f08875090748f1879db7b8783eef981e6bf2ea2d/0c121/images/posts/code_splitting_01.png" alt="image"><br>&emsp;&emsp;如果我们延迟加载这些代码段直到初始渲染结束会怎样？它可以让用户更快的看到界面并进行交互。<br>&emsp;&emsp;在这篇文章，我将向你展示如何使用<strong>Vue.js</strong> 和 <strong>Webpack</strong>将单页应用拆分成可以动态加载的更理想的大小。<br>### 异步组件<br>&emsp;&emsp;Code splitting 的关键就是异步组件（<em>async components</em>），这个组件的定义就是异步加载（包括它的模板，数据，方法等等）。<br>&emsp;&emsp;首先让我们用<em>component API</em> 即 <em>Vue.component(name, definition)</em> 声明一个组件。不同于将定义对象作为第二个参数，异步组件有一个函数，这个函数有两个显著的特点：<br>- 它执行 Promise，拥有一个 resolve 参数<br>- 它是一个工厂函数，也就是说它返回一个对象(在本例中是组件定义)<br><br><pre><code><br>Vue.component(‘async-component’, (resolve) =&gt; {<br>  resolve({<br>    template: ‘<div>Async Component</div>‘,<br>    props: [ ‘myprop’ ]<br>  });<br>});<br></code></pre><br><br>异步组件是 <em>Code splitting</em> 的第一步，因为我们现在才有了一个抽象的机制。<br>### 动态模块加载<br>&emsp;&emsp;我们还需要 <em>webpack</em> 的帮助，假设我们将组件定义抽象为ES6模块文件:<br><br>  <strong>AsyncComponent.js</strong><br><br><pre><code><br>export default {<br>  template: ‘<div>Async Component</div>‘,<br>  props: [ ‘myprop’ ]<br>}<br></code></pre><br><br>&emsp;&emsp;我们怎么让Vue.js加载它呢？你可能会想试试这样的方法：<br><br><pre><code><br>import AsyncComponent from ‘./AsyncComponent.js’`;<br>Vue.component(‘async-component’, AsyncComponent);<br></code></pre><br><br>&emsp;&emsp;但是这是静态的并且在编译时解析，如果我们想要获得<em>Code splitting</em> 的好处，我们需要的是在运行的应用中动态地加载。<br>#### import()<br>&emsp;&emsp;目前，用JavaScript来动态的加载模块是不可能的。但是，ECMAScript有一个动态模块加载函数叫做 <em>import()</em>  。<br>&emsp;&emsp;Webpack已经有了一个import()的实现，并将其作为一个代码分割点，在创建包时，将所请求的模块放入一个单独的文件中（一个单独的chunk，实际上，现在把它看作单独的一个文件）。<br>&emsp;&emsp;import() 将文件名作为一个参数并返回一个Promise。下面是我们如何加载上面的模块：<br><br><pre><code><br>import(/<em> webpackChunkName: “async-component” </em>/ ‘./AsyncComponent.js’)<br>  .then((AsyncComponent) =&gt; {<br>    console.log(AsyncComponent.default.template);<br>    // Output: <div>Async Component</div><br>  });<br></code></pre><br><br>&gt; <strong><em>注：如果你使用Babel，你需要添加</em></strong> <em>syntax-dynamic-import</em> 插件<strong><em>以便Babel可以正确的解析。</em></strong><br><br>现在，但你构建项目的时候，你会注意到这些模块出现在它自己的文件中了：<br><table><br>    <tr><br>      <th>Asset</th><br>      <th>Chuck Name</th><br>    </tr><br>    <tr><br>      <td>bundle.main.js</td><br>      <td>main</td><br>    </tr><br>    <tr><br>      <td>bundle.0.js</td><br>      <td>async-component</td><br>    </tr><br></table><blockquote><p><strong><em>你可以给动态导入的模块加一个名字，让它更容易识别；只需在文件名前面添加一个注释，就像我在上面的例子中所做的那样。</em></strong></p><h3 id="动态组件加载"><a href="#动态组件加载" class="headerlink" title="动态组件加载"></a>动态组件加载</h3></blockquote><p>&emsp;&emsp;因为 <em>import()</em> 返回一个Promise，我们可以将它和 <em>Vue</em> 的异步组件功能结合使用。Webpack将单独打包异步组件，并通过AJAX将其动态加载到应用程序中。</p><p>  <strong>main.js</strong>  </p><pre><code>import Vue from 'vue';Vue.component('async-component', (resolve) => {  import('./AsyncComponent.js')    .then((AsyncComponent) => {      resolve(AsyncComponent.default);    });});new Vue({   el: '#app' });</code></pre>  <p>  <strong>index.html</strong>  </p><pre><code><div id="app">  <p>This part is included in the page load</p>  <async-component></async-component></div><script src="bundle.main.js"></script></code></pre>    <p>  <strong>页面初始加载时：</strong>  </p><pre><code><div id="app">  <p>This part is included in the page load</p></div></code></pre>        <p>  当main.js运行的时候，它将启动异步组件模块的请求（这是自动实现的，因为 <em>webpack</em> 的 <em>import()</em> 包含了AJAX加载模块的代码）。<br>  如果Ajax成功返回模块，Promise 完成并且渲染组件，页面将会被渲染成这样：  </p> <pre><code><div id="app">  <p>This part is included in the page load</p>  <div>Async Component</div></div></code></pre>     <p><strong>下图可以更好地帮助你理解：</strong>  </p><p><img src="https://d33wubrfki0l68.cloudfront.net/67be4bc46f37830bc390a151acb3fffe971062ec/eac15/images/posts/code_splitting_02.png" alt="image"></p><h3 id="single-file-component"><a href="#single-file-component" class="headerlink" title="single file component"></a>single file component</h3><p>&emsp;&emsp;Vue 实现 <em>Code Splitting</em> 的特殊方式就是使用 <em>single file component</em>。下面是使用single file component的代码重构：</p><p><strong>AsyncComponent.vue</strong>    </p><pre><code><template>  <div>Async Component</div></template><script>  export default {    props: [ 'myprop' ]  }</script></code></pre>     <p><strong>导入的语法也更加简洁</strong>  </p><pre><code>new Vue({   el: '#app',  components: {    AsyncComponent: () => import('./AsyncComponent.vue')  }});</code></pre>    <h3 id="Code-Splitting-架构"><a href="#Code-Splitting-架构" class="headerlink" title="Code Splitting 架构"></a>Code Splitting 架构</h3><p>&emsp;&emsp;这是无关技术的部分，问题就是我们怎么为一个app构建一个code splitting ？<br>&emsp;&emsp;最直接的方法就是按照界面来，比如，你的app上有两个界面，一个home，一个about。这两个界面是由两个组件（home.vue about.vue）构成，那么这两个组件就可以是拆分的点。<br>&emsp;&emsp;另外，你也可以对任何有条件的组件（选项卡、弹窗、下拉菜单等等）或者是footer进行拆分。</p><blockquote><p>原文地址：<a href="https://vuejsdevelopers.com/2017/07/03/vue-js-code-splitting-webpack/" target="_blank" rel="noopener">Code Splitting with Vue.js And Webpack</a><br>译者：<a href="http://www.damerwang.com">Damer Wang</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;用webpack来打包你的单页应用的一个可能的缺点是你可能会得到一个非常大的打包文件，有时甚至会有几兆大小。   &lt;/p&gt;
&lt;table&gt;&lt;br&gt;    &lt;tr&gt;&lt;br&gt;      &lt;th&gt;Asset&lt;/th&gt;&lt;br&gt;      &lt;th&gt;Size&lt;/
      
    
    </summary>
    
    
      <category term="vue webpack" scheme="http://www.damerwang.com/tags/vue-webpack/"/>
    
  </entry>
  
  <entry>
    <title>Damer-cli：帮你优化HTTP请求结构的脚手架</title>
    <link href="http://www.damerwang.com/2017/12/09/page1/"/>
    <id>http://www.damerwang.com/2017/12/09/page1/</id>
    <published>2017-12-09T08:10:30.000Z</published>
    <updated>2017-12-09T09:42:35.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 写在前面：最近一直在用 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a>       做后台管理系统。大家也都知道这种后台管理系统，用组件库的话很快就能搭出一个像样的界面出来，但是他的请求远比单页面复杂得多，逻辑也更复杂一点。http请求有一个清晰的结构不仅有利于开发，也有利别人接手，本篇文章就是给大家分享一些优化的方法，第一次写文章，如果有的地方写的不对或是没有表达清楚，欢迎大家给我提 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">issues</a></p></blockquote><h3 id="代码结构就不展示了，大家可以去-这里-查看，本篇文章主要给大家分享一下其中的-api-和-store"><a href="#代码结构就不展示了，大家可以去-这里-查看，本篇文章主要给大家分享一下其中的-api-和-store" class="headerlink" title="代码结构就不展示了，大家可以去 这里 查看，本篇文章主要给大家分享一下其中的 api 和 store"></a>代码结构就不展示了，大家可以去 <a href="https://github.com/brushbird/Damer-cli" target="_blank" rel="noopener">这里</a> 查看，本篇文章主要给大家分享一下其中的 api 和 store</h3><ul><li><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="1-urlConfig-js"><a href="#1-urlConfig-js" class="headerlink" title="1. urlConfig.js"></a>1. urlConfig.js</h4></li></ul><pre><code>// 在这个页面中，将后台的请求集合起来，统一管理(function() {    var BASE_URL = window.oPageConfig.oData.BASE_URL;    function URLConfig(which, data) {        var url;        switch (which) {            /*********************基础信息*********************/            case 'baseInfo':                return BASE_URL + 'info'; // 菜单列表        }    }    window.URLConfig = URLConfig;})();</code></pre><h4 id="2-index-js"><a href="#2-index-js" class="headerlink" title="2. index.js"></a>2. index.js</h4><pre><code>import http from './http.js';import urlConfig from './urlConfig.js';//在这里注册 HTTP请求export function getBaseInfo (){    return http({url: URLConfig('baseInfo')});}</code></pre><h4 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h4><pre><code>import * as Api from 'api/index.js'methods: {  loadData: function() {    Api.getBaseInfo().then((data)=>{        // todo    }, error=>{        //todo    })  }},</code></pre><h5 id="这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在-api-中进行修改就可以了。-同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。"><a href="#这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在-api-中进行修改就可以了。-同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。" class="headerlink" title="这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在 api 中进行修改就可以了。 同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。"></a>这种方式的好处在于统一管理HTTP请求，便于维护和修改，比如后台进行了修改接口地址或是增加删除参数之类的操作，我们就只要在 api 中进行修改就可以了。 同样，在多个页面用到同一个请求也只需要更改一下参数就可以了。</h5><ul><li><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><blockquote><p>vuex的使用方法不用多说，这里主要是将公共方法抽取出来，放到actions中去，具体操作如下： </p></blockquote></li></ul><pre><code>import testA from './testA.js';import testB from './testB.js';import * as Api from 'src/api';const state = {};const getters = {};const actions = {    //在这里将公共的操作提取出来，对公共的数据进行统一的操作    //获取信息    loadBaseInfo({ dispatch, commit }, params) {        return new Promise((resolve, reject) => {            Api.getBaseInfo(params).then(data => {                commit('UPDATE_BASEINFO', data.list);                resolve(data);            }, error => {                reject(error);            });        })    }};const mutations = {    UPDATE_BASEINFO(state, data) {        //todo    }};export default {    namespaced: true,    state,    getters,    actions,    mutations,    modules: {        testA,        testB,    }}</code></pre><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><pre><code>import { mapState, mapMutations, mapActions } from "vuex";computed: {    ...mapState("modules/testA", {      变量名: state => state.变量名,    }),    ...mapState("modules/testB", {      变量名: state => state.变量名,    })},methods: {    //注意这里的modules是指引用在index.js中的父组件的模块名称    /*例如    *在store/index.js中    *  " import baseModule from './modules/base.js'; "    *那么下面的引用路径就要变成("baseModule/testA");    */    ...mapActions("modules/testA", [      "方法名"    ]),     ...mapActions("modules/testB", [      "方法名"    ]),    ...mapMutations("modules/testA", [      "方法名"    ]),    ...mapMutations("modules/testB", [      "方法名"    ]),}</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p> 对于一个组件拥有多个组件，同时各组件之间有数据联系的情况，可以通过为每个组件都建立一个store文件，然后在父组件中引用的方式解决，当然，在子文件中都需要加上 ==namespaced: true== </p></blockquote><h5 id="这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护"><a href="#这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护" class="headerlink" title="这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护"></a>这种方式的好处在于数据处理的操作全在vuex中进行，组件只负责渲染，代码逻辑都在一个地方，降低了别人熟悉你的代码的难度，同样也有利于维护</h5><h4 id="写在最后：-我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用-api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到-issues-中来。同样，如果这篇文章有什么问题的话也请移步-这里-。"><a href="#写在最后：-我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用-api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到-issues-中来。同样，如果这篇文章有什么问题的话也请移步-这里-。" class="headerlink" title="==写在最后：== 我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用 api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到 issues 中来。同样，如果这篇文章有什么问题的话也请移步 这里 。"></a>==写在最后：== 我目前的处理方式就是两者相结合，在api中注册所有的请求接口，对于不复杂的界面直接引用 api，复杂的组件就抽离出来，在store中处理。这是我最近工作的一点心得，把它写出来希望能为不知道的小伙伴提供一点帮助，知道这种方法的大神们，如果有更好的处理方式又方便分享的话，欢迎到 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">issues</a> 中来。同样，如果这篇文章有什么问题的话也请移步 <a href="https://github.com/brushbird/Damer-cli/issues" target="_blank" rel="noopener">这里</a> 。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 写在前面：最近一直在用 &lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;       做后台管理系统。大家也都知道这种后台管理系统，用组件库的话很快就能搭
      
    
    </summary>
    
    
  </entry>
  
</feed>
